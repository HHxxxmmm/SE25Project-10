# 车票日期范围查询功能说明

## 功能概述

为本人车票页面添加了按出发日期过滤的逻辑，支持设置上下限日期范围，查询出发日期在该区间内的车票。该功能提供了灵活的筛选方式，帮助用户快速找到特定时间段的车票。

## 功能特性

### 1. 日期范围查询
- 支持设置开始日期和结束日期
- 查询出发日期在指定区间内的车票
- 日期格式：yyyy-MM-dd（如：2025-07-01）

### 2. 多条件筛选
- 支持单独按日期范围查询
- 支持按车票状态和日期范围组合查询
- 提供精确的筛选条件

### 3. 数据验证
- 验证日期格式的正确性
- 验证开始日期不能晚于结束日期
- 提供友好的错误提示信息

## 数据库设计

### Repository层新增查询方法

在 `TicketRepository` 中添加了两个新的查询方法：

```java
/**
 * 根据乘客ID和出发日期范围查询有效车票（按创建时间倒序）
 */
@Query("SELECT t FROM Ticket t WHERE t.passengerId = :passengerId " +
       "AND t.ticketStatus IN (0, 1, 2) " + // 0-待支付, 1-未使用, 2-已使用
       "AND t.travelDate >= :startDate " +
       "AND t.travelDate <= :endDate " +
       "ORDER BY t.createdTime DESC")
List<Ticket> findValidTicketsByPassengerAndDateRange(
        @Param("passengerId") Long passengerId,
        @Param("startDate") LocalDate startDate,
        @Param("endDate") LocalDate endDate);

/**
 * 根据乘客ID、车票状态和出发日期范围查询车票（按创建时间倒序）
 */
@Query("SELECT t FROM Ticket t WHERE t.passengerId = :passengerId " +
       "AND t.ticketStatus = :ticketStatus " +
       "AND t.travelDate >= :startDate " +
       "AND t.travelDate <= :endDate " +
       "ORDER BY t.createdTime DESC")
List<Ticket> findByPassengerIdAndStatusAndDateRange(
        @Param("passengerId") Long passengerId,
        @Param("ticketStatus") byte ticketStatus,
        @Param("startDate") LocalDate startDate,
        @Param("endDate") LocalDate endDate);
```

## API接口设计

### 1. 按日期范围查询车票

**接口地址**: `GET /api/ticket/my-tickets/date-range`

**请求参数**:
- `userId` (Long): 用户ID
- `startDate` (String): 开始日期，格式：yyyy-MM-dd
- `endDate` (String): 结束日期，格式：yyyy-MM-dd

**示例请求**:
```
GET /api/ticket/my-tickets/date-range?userId=1&startDate=2025-07-01&endDate=2025-07-31
```

**响应示例**:
```json
{
  "status": "SUCCESS",
  "message": "获取成功",
  "tickets": [
    {
      "ticketId": 1,
      "ticketNumber": "T123456789",
      "orderId": 1,
      "orderNumber": "O123456789",
      "trainId": 1,
      "trainNumber": "G1",
      "departureStopId": 1,
      "departureStationName": "北京南站",
      "arrivalStopId": 2,
      "arrivalStationName": "上海虹桥站",
      "travelDate": "2025-07-15",
      "carriageNumber": "01",
      "seatNumber": "1A",
      "price": 553.50,
      "ticketStatus": 1,
      "ticketStatusText": "未使用",
      "ticketType": 1,
      "ticketTypeText": "成人票",
      "createdTime": "2025-06-30T10:30:00",
      "paymentTime": "2025-06-30T10:35:00",
      "orderStatusText": "已支付"
    }
  ],
  "timestamp": "2025-06-30T15:30:00"
}
```

### 2. 按状态和日期范围查询车票

**接口地址**: `GET /api/ticket/my-tickets/status-date-range`

**请求参数**:
- `userId` (Long): 用户ID
- `ticketStatus` (Byte): 车票状态（0-待支付, 1-未使用, 2-已使用, 3-已退票, 4-已改签）
- `startDate` (String): 开始日期，格式：yyyy-MM-dd
- `endDate` (String): 结束日期，格式：yyyy-MM-dd

**示例请求**:
```
GET /api/ticket/my-tickets/status-date-range?userId=1&ticketStatus=1&startDate=2025-07-01&endDate=2025-07-31
```

**响应格式**: 与按日期范围查询相同

## 业务逻辑实现

### Service层实现

在 `TicketServiceImpl` 中实现了两个新的业务方法：

#### 1. 按日期范围查询
```java
@Override
public MyTicketResponse getMyTicketsByDateRange(Long userId, LocalDate startDate, LocalDate endDate) {
    try {
        // 1. 验证用户和乘客关联关系
        Optional<User> userOpt = userRepository.findById(userId);
        if (!userOpt.isPresent()) {
            return MyTicketResponse.failure("用户不存在");
        }
        
        User user = userOpt.get();
        if (user.getPassengerId() == null) {
            return MyTicketResponse.failure("用户未关联乘客信息");
        }
        
        // 2. 验证日期范围
        if (startDate == null || endDate == null) {
            return MyTicketResponse.failure("开始日期和结束日期不能为空");
        }
        
        if (startDate.isAfter(endDate)) {
            return MyTicketResponse.failure("开始日期不能晚于结束日期");
        }
        
        // 3. 查询车票
        List<Ticket> tickets = ticketRepository.findValidTicketsByPassengerAndDateRange(
                user.getPassengerId(), startDate, endDate);
        
        // 4. 转换为响应格式
        List<MyTicketResponse.MyTicketInfo> ticketInfos = convertToMyTicketInfo(tickets);
        
        return MyTicketResponse.success(ticketInfos);
        
    } catch (Exception e) {
        System.err.println("获取本人车票失败: " + e.getMessage());
        return MyTicketResponse.failure("获取本人车票失败: " + e.getMessage());
    }
}
```

#### 2. 按状态和日期范围查询
```java
@Override
public MyTicketResponse getMyTicketsByStatusAndDateRange(Long userId, Byte ticketStatus, LocalDate startDate, LocalDate endDate) {
    try {
        // 1. 验证用户和乘客关联关系
        Optional<User> userOpt = userRepository.findById(userId);
        if (!userOpt.isPresent()) {
            return MyTicketResponse.failure("用户不存在");
        }
        
        User user = userOpt.get();
        if (user.getPassengerId() == null) {
            return MyTicketResponse.failure("用户未关联乘客信息");
        }
        
        // 2. 验证日期范围
        if (startDate == null || endDate == null) {
            return MyTicketResponse.failure("开始日期和结束日期不能为空");
        }
        
        if (startDate.isAfter(endDate)) {
            return MyTicketResponse.failure("开始日期不能晚于结束日期");
        }
        
        // 3. 查询车票
        List<Ticket> tickets = ticketRepository.findByPassengerIdAndStatusAndDateRange(
                user.getPassengerId(), ticketStatus, startDate, endDate);
        
        // 4. 转换为响应格式
        List<MyTicketResponse.MyTicketInfo> ticketInfos = convertToMyTicketInfo(tickets);
        
        return MyTicketResponse.success(ticketInfos);
        
    } catch (Exception e) {
        System.err.println("获取本人车票失败: " + e.getMessage());
        return MyTicketResponse.failure("获取本人车票失败: " + e.getMessage());
    }
}
```

### Controller层实现

在 `TicketController` 中添加了两个新的API端点：

#### 1. 按日期范围查询端点
```java
@GetMapping("/my-tickets/date-range")
public ResponseEntity<MyTicketResponse> getMyTicketsByDateRange(
        @RequestParam Long userId,
        @RequestParam String startDate,
        @RequestParam String endDate) {
    try {
        LocalDate start = LocalDate.parse(startDate);
        LocalDate end = LocalDate.parse(endDate);
        MyTicketResponse response = ticketService.getMyTicketsByDateRange(userId, start, end);
        if ("SUCCESS".equals(response.getStatus())) {
            return ResponseEntity.ok(response);
        } else {
            return ResponseEntity.badRequest().body(response);
        }
    } catch (Exception e) {
        return ResponseEntity.badRequest().body(MyTicketResponse.failure("日期格式错误，请使用yyyy-MM-dd格式"));
    }
}
```

#### 2. 按状态和日期范围查询端点
```java
@GetMapping("/my-tickets/status-date-range")
public ResponseEntity<MyTicketResponse> getMyTicketsByStatusAndDateRange(
        @RequestParam Long userId,
        @RequestParam Byte ticketStatus,
        @RequestParam String startDate,
        @RequestParam String endDate) {
    try {
        LocalDate start = LocalDate.parse(startDate);
        LocalDate end = LocalDate.parse(endDate);
        MyTicketResponse response = ticketService.getMyTicketsByStatusAndDateRange(userId, ticketStatus, start, end);
        if ("SUCCESS".equals(response.getStatus())) {
            return ResponseEntity.ok(response);
        } else {
            return ResponseEntity.badRequest().body(response);
        }
    } catch (Exception e) {
        return ResponseEntity.badRequest().body(MyTicketResponse.failure("日期格式错误，请使用yyyy-MM-dd格式"));
    }
}
```

## 错误处理

### 1. 日期格式错误
- 错误信息：`"日期格式错误，请使用yyyy-MM-dd格式"`
- 处理方式：捕获 `LocalDate.parse()` 异常

### 2. 日期范围验证
- 错误信息：`"开始日期和结束日期不能为空"`
- 处理方式：检查参数是否为null

### 3. 日期逻辑错误
- 错误信息：`"开始日期不能晚于结束日期"`
- 处理方式：使用 `startDate.isAfter(endDate)` 检查

### 4. 用户验证错误
- 错误信息：`"用户不存在"` 或 `"用户未关联乘客信息"`
- 处理方式：检查用户存在性和乘客关联关系

## 前端集成建议

### 1. 日期选择器
- 使用日期选择器组件
- 支持开始日期和结束日期的选择
- 提供日期格式验证

### 2. 筛选条件组合
- 支持状态筛选和日期范围筛选的组合
- 提供重置筛选条件的功能
- 显示当前筛选条件

### 3. 用户体验优化
- 提供默认日期范围（如：最近一个月）
- 支持快速选择常用日期范围
- 显示筛选结果数量

### 4. 错误提示
- 显示日期格式错误提示
- 显示日期范围逻辑错误提示
- 提供友好的错误信息

## 测试用例

### Postman测试集合

已更新 `postman_collection.json`，添加了以下测试用例：

1. **根据出发日期范围获取本人车票**
   - 接口：`GET /api/ticket/my-tickets/date-range`
   - 参数：userId=1, startDate=2025-07-01, endDate=2025-07-31

2. **根据状态和日期范围获取本人车票**
   - 接口：`GET /api/ticket/my-tickets/status-date-range`
   - 参数：userId=1, ticketStatus=1, startDate=2025-07-01, endDate=2025-07-31

### 测试场景

1. **正常查询场景**
   - 查询指定日期范围内的车票
   - 验证返回的车票日期都在指定范围内

2. **边界值测试**
   - 开始日期等于结束日期
   - 查询未来日期范围
   - 查询过去日期范围

3. **错误处理测试**
   - 日期格式错误
   - 开始日期晚于结束日期
   - 用户不存在
   - 用户未关联乘客

4. **组合查询测试**
   - 状态筛选 + 日期范围筛选
   - 验证返回结果符合所有筛选条件

## 性能考虑

### 1. 数据库索引
- 确保 `tickets` 表的 `passenger_id` 和 `travel_date` 字段有适当的索引
- 考虑复合索引 `(passenger_id, travel_date, ticket_status)`

### 2. 查询优化
- 使用 JPA 的 `@Query` 注解优化查询
- 按创建时间倒序排列，便于分页

### 3. 缓存策略
- 考虑对常用日期范围查询结果进行缓存
- 使用 Redis 缓存热门查询结果

## 总结

车票日期范围查询功能为用户提供了灵活的筛选方式，支持按出发日期区间查询车票，并可以与车票状态筛选组合使用。该功能具有以下特点：

1. **功能完整**：支持单独按日期范围查询和组合条件查询
2. **数据验证**：完善的参数验证和错误处理
3. **用户友好**：清晰的API设计和错误提示
4. **性能优化**：合理的数据库查询和索引设计
5. **易于扩展**：模块化设计，便于后续功能扩展

该功能已完全集成到现有系统中，与原有的车票查询功能无缝配合，为用户提供更好的车票管理体验。 