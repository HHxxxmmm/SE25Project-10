# 提交订单异步处理方案

## 方案概述

为了解决高并发场景下的性能和正确性问题，我们采用**异步创建订单 + 轮询获取订单ID**的方案：

1. **购票API**：立即返回订单号，异步创建订单
2. **前端轮询**：定期查询订单ID，获取到后跳转支付页面
3. **RabbitMQ**：异步处理订单创建和车票分配

## 技术优势

### 1. 高并发性能
- **购票API响应快**：只做验证和库存预减，不涉及数据库写入
- **数据库压力小**：订单创建通过消息队列异步处理
- **可扩展性强**：可以增加多个消费者处理订单

### 2. 数据一致性
- **分布式锁**：确保库存操作的原子性
- **事务处理**：订单和车票在同一个事务中创建
- **错误处理**：失败时自动回滚库存

### 3. 用户体验
- **即时反馈**：购票API立即返回结果
- **进度提示**：显示"正在处理订单..."
- **超时处理**：10秒后提示用户稍后查看

## 流程详解

### 1. 购票API调用
```javascript
// 前端发送购票请求
const bookingRequest = {
    userId: 1,
    trainId: 1,
    departureStopId: 1,
    arrivalStopId: 2,
    travelDate: "2025-07-10",
    carriageTypeId: 1,
    passengers: [
        { passengerId: 1, ticketType: 1 },
        { passengerId: 2, ticketType: 3 }
    ]
};

// 后端立即返回
{
    "status": "SUCCESS",
    "message": "购票成功",
    "orderNumber": "ORD2025071012345678",
    "orderId": null,
    "totalAmount": null,
    "orderTime": "2025-07-10T16:30:00"
}
```

### 2. 异步订单处理
```java
// RabbitMQ消息
{
    "userId": 1,
    "trainId": 1,
    "departureStopId": 1,
    "arrivalStopId": 2,
    "travelDate": "2025-07-10",
    "carriageTypeId": 1,
    "passengers": [...],
    "orderNumber": "ORD2025071012345678"
}

// OrderProcessor处理
1. 创建订单记录
2. 计算总金额
3. 创建车票记录
4. 分配座位
5. 保存到数据库
```

### 3. 前端轮询获取订单ID
```javascript
// 轮询逻辑
const pollOrderId = async () => {
    const orderResponse = await orderAPI.getOrderIdByOrderNumber(orderNumber);
    
    if (orderResponse.status === 'SUCCESS') {
        // 获取到订单ID，跳转支付页面
        window.location.href = `/payment?orderId=${orderResponse.orderId}`;
    } else if (orderResponse.status === 'NOT_FOUND') {
        // 订单尚未创建，继续轮询
        setTimeout(pollOrderId, 200);
    }
};
```

## 关键组件

### 1. 后端API
- **购票API** (`/api/ticket/book`)：验证 + 预减库存 + 发送消息
- **查询订单ID API** (`/api/orders/order-id`)：根据订单号查询订单ID

### 2. 消息队列
- **RabbitMQ**：异步处理订单创建
- **OrderProcessor**：消费消息，创建订单和车票

### 3. 前端逻辑
- **轮询机制**：每200毫秒查询一次，最多15次
- **状态提示**：显示处理进度
- **错误处理**：超时和异常处理

## 测试场景

### 1. 正常流程
1. 用户点击"提交订单"
2. 购票API立即返回订单号
3. 前端开始轮询查询订单ID
4. 异步处理完成，订单创建成功
5. 前端获取到订单ID，跳转支付页面

### 2. 高并发场景
1. 1000个用户同时购票
2. 购票API快速响应，不阻塞
3. 订单通过消息队列异步处理
4. 前端轮询获取各自的订单ID

### 3. 异常处理
1. **库存不足**：立即返回错误
2. **时间冲突**：立即返回错误
3. **订单创建失败**：回滚库存
4. **轮询超时**：提示用户稍后查看

## 性能指标

### 1. 响应时间
- **购票API**：< 100ms（不包含数据库写入）
- **订单创建**：< 2s（异步处理）
- **轮询间隔**：200ms
- **总等待时间**：< 3s

### 2. 并发能力
- **购票API**：支持1000+并发
- **消息队列**：可扩展多个消费者
- **数据库**：减少写入压力

### 3. 可用性
- **降级方案**：轮询超时后提示用户
- **重试机制**：消息处理失败自动重试
- **监控告警**：队列积压和错误监控

## 注意事项

1. **轮询频率**：1秒间隔，避免过于频繁
2. **超时设置**：3秒超时，平衡用户体验和系统负载
3. **错误处理**：完善的异常处理和回滚机制
4. **监控告警**：监控队列积压和处理时间
5. **用户体验**：清晰的进度提示和错误信息

## 相关文件

### 后端文件
- `TicketServiceImpl.java` - 购票服务（异步方案）
- `OrderController.java` - 订单控制器（添加查询订单ID API）
- `OrderProcessor.java` - 订单处理器（异步创建订单）
- `OrderMessage.java` - 订单消息DTO

### 前端文件
- `api.js` - API服务（添加查询订单ID方法）
- `SubmitOrder/index.jsx` - 提交订单页面（轮询逻辑）

这个方案既保证了高并发性能，又确保了数据一致性，同时提供了良好的用户体验。 