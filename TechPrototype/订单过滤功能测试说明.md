# 订单过滤功能测试说明

## 功能概述

订单页面支持四种过滤条件，与后端API完全一致：

1. **订单号过滤**：支持模糊匹配
2. **车次号过滤**：支持模糊匹配
3. **出发日期过滤**：按车票的出发日期范围过滤
4. **订单状态过滤**：精确匹配订单状态

## 后端实现

### 1. API接口
```java
@GetMapping("/my/filter")
public MyOrderResponse getMyOrdersByConditions(
    @RequestParam Long userId,
    @RequestParam(required = false) String orderNumber,
    @RequestParam(required = false) LocalDate startDate,
    @RequestParam(required = false) LocalDate endDate,
    @RequestParam(required = false) Byte orderStatus,
    @RequestParam(required = false) String trainNumber)
```

### 2. 过滤逻辑
```java
// 根据条件查询订单
if (orderNumber != null && !orderNumber.trim().isEmpty()) {
    // 按订单号查询
    orders = orderRepository.findByUserIdAndOrderNumberContaining(userId, orderNumber.trim());
} else if (orderStatus != null) {
    // 按订单状态查询
    orders = orderRepository.findByUserIdAndOrderStatus(userId, orderStatus);
} else if (startDate != null && endDate != null) {
    // 按车票出发时间范围查询
    orders = orderRepository.findByUserIdAndTicketTravelDateBetween(userId, startDate, endDate);
} else {
    // 查询所有订单
    orders = orderRepository.findByUserIdOrderByOrderTimeDesc(userId);
}

// 车次号在内存中过滤
if (trainNumber != null && !trainNumber.trim().isEmpty()) {
    orderInfos = orderInfos.stream()
            .filter(orderInfo -> orderInfo.getTrainNumber() != null && 
                    orderInfo.getTrainNumber().contains(trainNumber.trim()))
            .collect(Collectors.toList());
}
```

### 3. Repository方法
- `findByUserIdAndOrderNumberContaining`：订单号模糊查询
- `findByUserIdAndOrderStatus`：订单状态精确查询
- `findByUserIdAndTicketTravelDateBetween`：出发日期范围查询
- `findByUserIdOrderByOrderTimeDesc`：获取所有订单

## 前端实现

### 1. 搜索表单状态
```javascript
const [searchForm, setSearchForm] = useState({
    orderNumber: '',        // 订单号
    trainNumber: '',        // 车次号
    orderStatus: 'all',     // 订单状态
    departureDateRange: null // 出发日期范围
});
```

### 2. 搜索处理逻辑
```javascript
const handleSearch = () => {
    const { orderNumber, trainNumber, orderStatus, departureDateRange } = searchForm;
    
    let status = null;
    if (orderStatus !== 'all') {
        status = parseInt(orderStatus);
    }
    
    let startDate = null;
    let endDate = null;
    if (departureDateRange && departureDateRange.length === 2) {
        startDate = departureDateRange[0].format('YYYY-MM-DD');
        endDate = departureDateRange[1].format('YYYY-MM-DD');
    }
    
    fetchOrders(orderNumber, startDate, endDate, status, trainNumber);
};
```

### 3. 界面组件
- **订单号输入框**：支持模糊匹配
- **车次号输入框**：支持模糊匹配
- **订单状态下拉框**：全部/待支付/已支付/已完成/已取消
- **出发日期范围选择器**：选择开始和结束日期

## 测试步骤

### 1. 基础功能测试

#### 步骤1：访问订单页面
- 打开浏览器访问：`http://localhost:3000/orders`
- 确认页面正常加载，显示所有订单

#### 步骤2：测试订单号过滤
- 在"订单号"输入框中输入部分订单号
- 点击"查询"按钮
- 验证只显示包含该订单号的订单

#### 步骤3：测试车次号过滤
- 在"车次号"输入框中输入车次号（如：G、D等）
- 点击"查询"按钮
- 验证只显示包含该车次号的订单

#### 步骤4：测试订单状态过滤
- 在"订单状态"下拉框中选择"待支付"
- 点击"查询"按钮
- 验证只显示待支付状态的订单

#### 步骤5：测试出发日期过滤
- 在"出发日期"范围选择器中选择日期范围
- 点击"查询"按钮
- 验证只显示出发日期在该范围内的订单

### 2. 组合过滤测试

#### 步骤1：订单号 + 状态组合
- 输入订单号并选择订单状态
- 点击"查询"按钮
- 验证结果同时满足两个条件

#### 步骤2：车次号 + 日期范围组合
- 输入车次号并选择出发日期范围
- 点击"查询"按钮
- 验证结果同时满足两个条件

#### 步骤3：多条件组合
- 同时设置多个过滤条件
- 点击"查询"按钮
- 验证结果满足所有条件

### 3. 边界情况测试

#### 步骤1：空条件查询
- 清空所有过滤条件
- 点击"查询"按钮
- 验证显示所有订单

#### 步骤2：无匹配结果
- 设置不存在的过滤条件
- 点击"查询"按钮
- 验证显示"暂无符合条件的订单"

#### 步骤3：特殊字符处理
- 在输入框中输入特殊字符
- 点击"查询"按钮
- 验证系统正确处理

## 验证要点

### 1. 数据正确性
- [ ] 订单号过滤结果正确
- [ ] 车次号过滤结果正确
- [ ] 订单状态过滤结果正确
- [ ] 出发日期过滤结果正确
- [ ] 组合过滤结果正确

### 2. 用户体验
- [ ] 输入框响应及时
- [ ] 查询按钮状态正确
- [ ] 加载状态显示正常
- [ ] 错误信息提示友好
- [ ] 清空功能正常工作

### 3. 性能表现
- [ ] 查询响应时间合理
- [ ] 大量数据查询不卡顿
- [ ] 内存使用正常
- [ ] 网络请求优化

## 常见问题

### 1. 过滤结果不正确
- 检查后端查询逻辑
- 验证数据库数据完整性
- 确认参数传递正确

### 2. 日期过滤不工作
- 检查日期格式是否正确
- 验证数据库中的日期数据
- 确认时区设置

### 3. 组合过滤异常
- 检查后端逻辑优先级
- 验证参数处理逻辑
- 确认前端参数传递

## 技术要点

### 1. 前后端一致性
- 参数名称统一
- 数据类型匹配
- 逻辑优先级一致

### 2. 性能优化
- 数据库索引优化
- 查询逻辑优化
- 前端缓存策略

### 3. 用户体验
- 实时搜索提示
- 智能默认值
- 操作反馈及时

## 总结

订单过滤功能实现了完整的前后端对接，支持四种过滤条件和组合查询，确保了数据一致性和用户体验的良好性。通过合理的API设计和优化，提供了高效、准确的订单查询功能。 